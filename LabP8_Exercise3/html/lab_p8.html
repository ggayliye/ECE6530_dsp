<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>lab_p8</title>
<meta name="generator" content="MATLAB 24.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-12-02">
<meta name="DC.source" content="lab_p8.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#2">Sampling, Aliasing and Reconstruction : Lab P8 Exercise: 3 Lab Exercises</a>
</li>
<li>
<a href="#3">Overvew</a>
</li>
<li>
<a href="#4">3.1 Down-Sampling</a>
</li>
<li>
<a href="#5">Questions.</a>
</li>
<li>
<a href="#6">Answers.</a>
</li>
<li>
<a href="#7">3.1a)</a>
</li>
<li>
<a href="#8">3.1b)</a>
</li>
<li>
<a href="#9">3.2 Reconstruction of Images</a>
</li>
<li>
<a href="#10">3.2a)</a>
</li>
<li>
<a href="#11">3.2b)</a>
</li>
<li>
<a href="#12">3.2c)</a>
</li>
<li>
<a href="#13">3.2d)</a>
</li>
<li>
<a href="#14">3.2e)</a>
</li>
<li>
<a href="#15">3.2f)</a>
</li>
<li>
<a href="#16">3.2g)</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="comment">% ==========================================================================</span>
<span class="comment">% ECE 5530/ ECE 6530 Digital Signal Processing, ECE Dep., The University of Utah</span>
<span class="comment">% Group Project</span>
<span class="comment">% Team: Kyle G. Gayliyev, Skylar Stockham, Eddie Franco</span>
<span class="comment">% ==========================================================================</span>
close <span class="string">all</span>;
clear;
</pre>
<h2 id="2">Sampling, Aliasing and Reconstruction : Lab P8 Exercise: 3 Lab Exercises</h2>
<h2 id="3">Overvew</h2>
<p>The objective in this lab is to introduce digital images as a second useful signal type. We will show how the A-to-D sampling and the D-to-A reconstruction processes are carried out for digital images. In particular, we will show a commonly used method of image zooming is actually D/A reconstruction, but it gives &ldquo;poor&rdquo; results&mdash;a later lab will revisit this issue and do a better job.</p>
<h2 id="4">3.1 Down-Sampling</h2>
<h2 id="5">Questions.</h2>
<p>Answer the following questions for the lighthouse picture, downsampled by two. a) Describe how the aliasing appears visually. Compare the original to the downsampled image. Which parts of the image show the aliasing effects most dramatically? b) This part is challenging: explain why the aliasing happens in the lighthouse image by using a &ldquo;frequency domain&rdquo; explanation. In other words, estimate the frequency of the features that are being aliased. Give this frequency as a number in cycles per pixel. (Note that the fence provides a sort of &ldquo;spatial chirp&rdquo; where the spatial frequency increases from left to right.) Can you relate your frequency estimate to the Sampling Theorem? You might try zooming in on a very small region of both the original and downsampled images.</p>
<h2 id="6">Answers.</h2>
<p>First, let's downsample the lighthouse picture by two. To do so, we upload the "lighthouse.mat" given file. Then, we apply the following formula to download it and save the downloaded file into a new variable.</p>
<pre class="codeinput">
<span class="comment">% Upload the "lighthouse.mat" given file</span>
<span class="comment">% lighthouse = importdata('lighthouse.mat');</span>
load <span class="string">lighthouse.mat</span>;

<span class="comment">% Downsampling the lighthouse image by factor of 2</span>
<span class="comment">%Formula: wp = ww(1:p:end,1:p:end); %downsampling the "ww" by a factor of p.</span>
downsampled_lh_2 = xx(1:2:end,1:2:end); <span class="comment">% size : 163x213</span>
whos;
</pre>
<pre class="codeoutput">  Name                    Size               Bytes  Class     Attributes

  downsampled_lh_2      163x213             277752  double              
  xx                    326x426            1111008  double              

</pre>
<h2 id="7">3.1a)</h2>
<p>Let's draw the image so that we can see and compare the results. Plot the original lighthouse image</p>
<pre class="codeinput">figure(<span class="string">'Name'</span>,<span class="string">'Lighthouse Original Image.'</span>);
clf;
imshow(xx); title(<span class="string">'Lighthouse Original Image.'</span>);

<span class="comment">% Plot the downsampled lighthouse image</span>
figure(<span class="string">'Name'</span>,<span class="string">'Lighthouse Downsampled Image by Factor of 2.'</span>);
clf;
imshow(downsampled_lh_2);
title(<span class="string">'Lighthouse Downsampled Image by Factor of 2.'</span>);

<span class="comment">% Comparing both on the same figure</span>
figure(<span class="string">'Name'</span>,<span class="string">'Comparing Lighthouse Original VS Downsampled Image by Factor of 2.'</span>);
clf;

subplot(1, 2, 1); imshow(xx);
title(<span class="string">'Original Image'</span>);
subplot(1, 2, 2); imshow(downsampled_lh_2);
title(<span class="string">'Downsampled Image by Factor of 2.'</span>);

<span class="comment">% subplot(2,1,1);</span>
<span class="comment">% imshow(xx);</span>
<span class="comment">% subplot(2,1,2);</span>
<span class="comment">% imshow(downsampled_lh);</span>

<span class="comment">% Aliasing appears visually as jagged edges, stair-step patterns, or</span>
<span class="comment">% a "pixelated" look, particularly along sharp transitions between</span>
<span class="comment">% colors or high-contrast areas in the image.</span>
<span class="comment">% In this example, the downsampled image appears less smooth and more</span>
<span class="comment">% distorted compared to the original lighthouse picture. Due to aliasing,</span>
<span class="comment">% some part of the fence, and the lighthouse itself appear blurred or</span>
<span class="comment">% distorted in the downsampled version. The aliasing effect is most</span>
<span class="comment">% noticeable in areas with fine details, such as the roof shingles,</span>
<span class="comment">% the fence, and the edges of the windows and doors.</span>

<span class="comment">% In summary, where high spatial frequencies are present in the downsampled</span>
<span class="comment">% image, aliasing is visually represented as a distorted, jagged pattern.</span>
<span class="comment">% The aliasing effect is especially apparent in regions with fine details,</span>
<span class="comment">% such the fence, the windows and door margins, and the roof shingles,</span>
<span class="comment">% when comparing the downsampled and original lighthouse image.</span>
</pre>
<img vspace="5" hspace="5" src="lab_p8_01.png" alt=""> <img vspace="5" hspace="5" src="lab_p8_02.png" alt=""> <img vspace="5" hspace="5" src="lab_p8_03.png" alt=""> <h2 id="8">3.1b)</h2>
<pre class="codeinput">
<span class="comment">% Frequency Domain Analysis</span>
reg_original = xx(100:150, 100:150); <span class="comment">%Extract the regions of interest</span>
reg_downsampled = downsampled_lh_2(50:75, 50:75);

<span class="comment">% Perform 2D Fourier Transform to analyze the frequency</span>
fft_original = fft2(reg_original);
fft_downsampled = fft2(reg_downsampled);

<span class="comment">% Frequency Estimation and Comparation</span>
figure(<span class="string">'Name'</span>,<span class="string">'Frequency Estimation and Comparation.'</span>);
subplot(1, 2, 1); imagesc(abs(fftshift(fft_original)));
title(<span class="string">'Original Image Frequency'</span>);
subplot(1, 2, 2); imagesc(abs(fftshift(fft_downsampled)));
title(<span class="string">'Downsampled Image by Factor of 2 Frequency.'</span>);

<span class="comment">% The lighthouse image's aliasing is caused by the downsampled image's</span>
<span class="comment">% inability to completely capture the high frequency information in the</span>
<span class="comment">% original image. This can be explained in the frequency domain by the</span>
<span class="comment">% fact that the frequency of the aliased features is more than half of the</span>
<span class="comment">% sampling rate. This is called the Nyquist rate, and it says that the</span>
<span class="comment">% sampling rate must to be more than twice the maximum frequency in the</span>
<span class="comment">% original image to avoid aliasing.</span>

<span class="comment">% The lighthouse image's peak frequency is around one cycle per pixel</span>
<span class="comment">% because the spatial frequency rises from left to right (the fence</span>
<span class="comment">% creates a kind of "spatial chirp"). The maximum frequency that the</span>
<span class="comment">% downsampled image can record is 0.5 cycles per pixel because it only</span>
<span class="comment">% has half as many pixels as the original. Aliasing would occur at</span>
<span class="comment">% frequencies higher than this.</span>

<span class="comment">% Because the downsampled image has a lower sampling rate (fewer pixels),</span>
<span class="comment">% it is unable to capture the high frequency information seen in the</span>
<span class="comment">% original image, which is why aliasing occurs. The Sampling Theorem, which</span>
<span class="comment">% asserts that the sample rate must be more than twice the maximum</span>
<span class="comment">% frequency in the signal in order to adequately capture it, is broken</span>
<span class="comment">% by this.</span>

<span class="comment">% The reason for the aliasing is that the high frequency information</span>
<span class="comment">% in the original image is not captured by the downsampled version.</span>
<span class="comment">% About 150 cycles per pixel is the highest frequency found in the original</span>
<span class="comment">% image. The sample Theorem states that the sample rate must be at least</span>
<span class="comment">% twice the highest frequency in the image, or 2*150 = 300 cycles per</span>
<span class="comment">% pixel, in order to prevent aliasing. Aliasing comes from the downsampled</span>
<span class="comment">% image's inability to capture high frequency information due to its</span>
<span class="comment">% sampling rate of only 150 cycles per pixel.</span>
</pre>
<img vspace="5" hspace="5" src="lab_p8_04.png" alt=""> <img vspace="5" hspace="5" src="lab_p8_05.png" alt=""> <h2 id="9">3.2 Reconstruction of Images</h2>
<pre class="codeinput">
<span class="comment">% When an image has been sampled, we can fill in the missing samples by</span>
<span class="comment">% doing interpolation. For images, this would be analogous which is part</span>
<span class="comment">% of the reconstruction process in a D-to-A converter. We could use a</span>
<span class="comment">% &ldquo;square pulse&rdquo; or a &ldquo;triangular pulse&rdquo; or other pulse shapes for the</span>
<span class="comment">% reconstruction.</span>

<span class="comment">% For the reconstruction experiment, we'll use the lighthouse image,</span>
<span class="comment">% down-sampled by a factor of 3.</span>

<span class="comment">% Downsampling the lighthouse image by factor of 3</span>
downsampled_lh_3 = xx(1:3:end,1:3:end); <span class="comment">% size : 109x142</span>
whos;

<span class="comment">% Plot the downsampled lighthouse image</span>
figure(<span class="string">'Name'</span>,<span class="string">'Lighthouse Downsampled Image by Factor of 3.'</span>);
clf;
imshow(downsampled_lh_3);
title(<span class="string">'Lighthouse Downsampled Image by Factor of 3.'</span>);
<span class="comment">% The goal is to reconstruct an approximation to the original lighthouse</span>
<span class="comment">% image, which is the size of 256x256, from the smaller down-sampled image.</span>
</pre>
<pre class="codeoutput">  Name                    Size               Bytes  Class     Attributes

  downsampled_lh_2      163x213             277752  double              
  downsampled_lh_3      109x142             123824  double              
  fft_downsampled        26x26               10816  double    complex   
  fft_original           51x51               41616  double    complex   
  reg_downsampled        26x26                5408  double              
  reg_original           51x51               20808  double              
  xx                    326x426            1111008  double              

</pre>
<img vspace="5" hspace="5" src="lab_p8_06.png" alt=""> <h2 id="10">3.2a)</h2>
<p>The simplest interpolation would be reconstruction with a square pulse which produces a &ldquo;zero-order hold.&rdquo; Here is a method that works for a one-dimensional signal (i.e., one row or one column of the image), assuming that we start with a row vector xr1, and the result is the row vector xr1hold.</p>
<pre class="codeinput">xr1 = (-2).^(0:6);
L = length(xr1); <span class="comment">% Length of the row vector xr1.</span>
nn = ceil((0.999:1:4*L)/4); <span class="comment">%&lt;-- Rounds up to the integer part</span>
xr1hold = xr1(nn); <span class="comment">% The result row vector</span>

<span class="comment">% TASK1: Plot the vector xr1hold to verify that it is a zero-order hold</span>
<span class="comment">% version derived from xr1.</span>

figure(<span class="string">'Name'</span>,<span class="string">'Zero-order Hold Version.'</span>);
clf;
subplot(2, 1, 1); stem(xr1hold); hold <span class="string">on</span>; plot(xr1hold);
xlabel(<span class="string">'Square Pulse Producing a &ldquo;zero-order Hold.&rdquo;'</span>)
ylabel(<span class="string">'The Result Row Vector'</span>);
hold <span class="string">off</span>;
title(<span class="string">'Plot of The Zero-order Hold Version.'</span>);
subplot(2, 1, 2); imshow(xr1hold);
title(<span class="string">'Image of The Zero-order Hold Version.'</span>);


<span class="comment">% TASK2: Explain what values are contained in the indexing vector nn.</span>
<span class="comment">% Answer: The indexing vector nn contains the indices used for zero-order</span>
<span class="comment">% hold interpolation. The values that are contained in the indexing vector</span>
<span class="comment">% nn are the integer values.</span>

<span class="comment">% TASK3: If xr1hold is treated as an interpolated version of xr1, then</span>
<span class="comment">% what is the interpolation factor?</span>
<span class="comment">% Answer: The interpolation factor is determined by the length of nn</span>
<span class="comment">% relative to the original row length. Interpolation_factor = length(nn)/L;</span>
<span class="comment">% Using this formula,</span>

Interpolation_factor = length(nn)/L;

fprintf(<span class="string">'The Interpolation Factor ='</span>);
disp(Interpolation_factor);

<span class="comment">% The Interpolation Factor =     4.</span>
</pre>
<pre class="codeoutput">The Interpolation Factor =     4

</pre>
<img vspace="5" hspace="5" src="lab_p8_07.png" alt=""> <img vspace="5" hspace="5" src="lab_p8_08.png" alt=""> <h2 id="11">3.2b)</h2>
<p>Process all the rows of downsampled_lh_3 to fill in the missing points. Use the zero-order hold idea from part (a) with an interpolation factor of 3. Call the result xholdrows. Display xholdrows as an image, and compare it to the downsampled image downsampled_lh_3; compare the size of the images as well as their content.</p>
<pre class="codeinput">xholdrows = zeros(size(downsampled_lh_3));
<span class="keyword">for</span> i = 1:size(downsampled_lh_3, 1)
    xr1 = downsampled_lh_3(i, :);  <span class="comment">% Take one row at a time</span>
    nn = ceil((0.999/1/4 * length(xr1)) / 4);
    xholdrows(i, :) = xr1(nn);
<span class="keyword">end</span>

<span class="comment">% Display xholdrows as an image</span>
figure(<span class="string">'Name'</span>,<span class="string">'Zero-Order Hold Interpolation for Rows.'</span>);
clf;
imshow(xholdrows);
title(<span class="string">'Zero-Order Hold Interpolation for Rows.'</span>);

<span class="comment">% Compare xholdrows to downsampled_lh_3 in terms of size and content.</span>

<span class="comment">% It saves the interpolated rows in the matrix xholdrows and uses the same</span>
<span class="comment">% zero-order hold interpolation method as in part (a) for every row.</span>


<span class="comment">% The final xholdrows matrix is shown as a picture, representing the full</span>
<span class="comment">% image with interpolated rows. This illustrates how zero-order hold</span>
<span class="comment">% interpolation is used to fill in the missing spots.</span>

size_downsampled_lh_3 = length(downsampled_lh_3);
size_xholdrows= length(xholdrows);

fprintf(<span class="string">' The Size of downsampled_lh_3 ='</span>);
disp(size_downsampled_lh_3);
fprintf(<span class="string">' The Size of xholdrows ='</span>);
disp(size_xholdrows);

<span class="comment">% xholdrows and downsampled_lh_3 both have some amount of data.</span>

<span class="comment">% xholdrows and downsampled_lh_3 picture comparation:</span>

figure(<span class="string">'Name'</span>,<span class="string">'xholdrows and downsampled_lh_3 Image Comparation.'</span>);
clf;
subplot(1, 2, 1); imshow(downsampled_lh_3);
title(<span class="string">'Downsampled Lighthouse Image By Factor of 3.'</span>);
subplot(1, 2, 2); imshow(xholdrows);
title(<span class="string">'xholdrows Image.'</span>);
</pre>
<pre class="codeoutput"> The Size of downsampled_lh_3 =   142

 The Size of xholdrows =   142

</pre>
<img vspace="5" hspace="5" src="lab_p8_09.png" alt=""> <img vspace="5" hspace="5" src="lab_p8_10.png" alt=""> <h2 id="12">3.2c)</h2>
<p>Process all the columns of xholdrows to fill in the missing points in each column and and call the result xhold. Compare the result (xhold) to the original image lighthouse.</p>
<pre class="codeinput">
<span class="comment">% Fill in the missing points for all columns in xholdrows using zero-order</span>
<span class="comment">% hold interpolation:</span>

xhold = zeros(size(xholdrows));
<span class="keyword">for</span> i = 1:size(xholdrows, 2)
    xr1 = xholdrows(:, i);  <span class="comment">% Take one column at a time</span>
    nn = ceil((0.999/1/4 * length(xr1)) / 4);
    xhold(:, i) = xr1(nn);
<span class="keyword">end</span>

<span class="comment">% Looping through columns,the code iterates through all the columns of the</span>
<span class="comment">% xholdrows matrix obtained in part (b).</span>
<span class="comment">% Like section (a), the zero-order hold interpolation approach is applied</span>
<span class="comment">% for each column, and the interpolated columns are stored in the matrix</span>
<span class="comment">% xhold. The interpolation for the full image is finished in this stage.</span>

figure(<span class="string">'Name'</span>,<span class="string">'xhold VS Original Lighthouse Image Comparation.'</span>);
clf;
subplot(1, 2, 1); imshow(xx);
title(<span class="string">'Original Lighthouse Image.'</span>);
subplot(1, 2, 2); imshow(xhold);
title(<span class="string">'xhold Image.'</span>);
</pre>
<img vspace="5" hspace="5" src="lab_p8_11.png" alt=""> <h2 id="13">3.2d)</h2>
<p>Linear interpolation can be done in MATLAB using the interp1 function (that&rsquo;s &ldquo;interp-one&rdquo;). Its default mode is linear interpolation, which is equivalent to using the &rsquo;*linear&rsquo; option, but interp1 can also do other types of polynomial interpolation.</p>
<pre class="codeinput">
<span class="comment">% TASK: For the example of a 1-D signal below, what is the interpolation</span>
<span class="comment">% factor when converting xr1_1 to xr1linear?</span>

n1 = 0:6;
xr1_1 = (-2).^n1;
tti = 0:0.1:6; <span class="comment">%-- locations between the n1 indices</span>
xr1linear = interp1(n1,xr1_1,tti); <span class="comment">%-- function is INTERP-ONE</span>

figure(<span class="string">'Name'</span>,<span class="string">'Signal Example For Section 3.2d.'</span>);
clf;
stem(tti,xr1linear);hold <span class="string">on</span>; plot(tti,xr1linear); hold <span class="string">off</span>;
title(<span class="string">'a 1-D Signal Example For Section 3.2d.'</span>);
xlabel(<span class="string">'Locations between the n1 indices'</span>)
ylabel(<span class="string">'Linear Interpolation'</span>)

<span class="comment">% Interpolation Factor Calculation</span>

L_xr1_1 = length(xr1_1); <span class="comment">% Length of the row vector xr1_1.</span>
Interpolation_factor_xr1_xr1linear = length(tti)/L_xr1_1;

fprintf(<span class="string">'The Interpolation Factor When Converting xr1_1 to xr1linear ='</span>);
disp(Interpolation_factor_xr1_xr1linear);

<span class="comment">% Answer: The Interpolation Factor Converting xr1_1 to xr1linear = 8.7143.</span>
</pre>
<pre class="codeoutput">The Interpolation Factor When Converting xr1_1 to xr1linear =    8.7143

</pre>
<img vspace="5" hspace="5" src="lab_p8_12.png" alt=""> <h2 id="14">3.2e)</h2>
<p>In the case of the lighthouse image, we need to carry out a linear interpolation operation on both the rows and columns of the down-sampled image downsampled_lh_3. This requires two calls to the interp1 function, because one call will only process all the columns of a matrix.</p>
<pre class="codeinput">
<span class="comment">% Name the interpolated output image xxlinear.</span>


<span class="comment">% Define the interpolation factor</span>
interpolation_f = 3;

<span class="comment">% Initialize a matrix for an interpolated image</span>
xxlinear = [];

<span class="comment">% Perform linear interpolation for each row</span>
<span class="comment">% Iterate through rows of the downsampled image, perform linear</span>
<span class="comment">% interpolation on each row separately.</span>
<span class="keyword">for</span> i = 1:size(downsampled_lh_3, 1)
    row = downsampled_lh_3(i, :);
    xxlinear_row = interp1(1:length(row), row, 1:(1/interpolation_f):length(row));
    xxlinear = [xxlinear; xxlinear_row];
<span class="keyword">end</span>
</pre>
<h2 id="15">3.2f)</h2>
<p>Task: Compare xxlinear to the original image lighthouse. Comment on the visual appearance of the &ldquo;reconstructed&rdquo; image versus the original; point out differences and similarities. Can the reconstruction (i.e., zooming) process remove the aliasing effects from the down-sampled lighthouse image?</p>
<pre class="codeinput">
<span class="comment">% xxlinear and original lighthouse image comparation:</span>

figure(<span class="string">'Name'</span>,<span class="string">'xxlinear and Original Lighthouse Image Comparation.'</span>);
clf;
subplot(2, 1, 1); imshow(xx);
title(<span class="string">'Original Lighthouse Image.'</span>);
subplot(2, 1, 2); imshow(xxlinear);
title(<span class="string">'xxlinear (Linear Interpolation) Image.'</span>);


<span class="comment">% Compared the &ldquo;reconstructed&rdquo; image versus the original, we observe that</span>
<span class="comment">% the &ldquo;reconstructed&rdquo; image is low quality. It has aliasing. It looks wider</span>
<span class="comment">% and bigger, there are lots of quality issues on the fence, lighthouse</span>
<span class="comment">% structure, house structure, and telescope. The number of items are</span>
<span class="comment">% similar.</span>

<span class="comment">%  The linear interpolation reconstruction (i.e., zooming) process didn't</span>
<span class="comment">% remove the aliasing effects from the down-sampled lighthouse image.</span>

<span class="comment">% No, a simple reconstruction process like zooming (interpolation) cannot</span>
<span class="comment">% completely remove aliasing effects from a down-sampled image like a</span>
<span class="comment">% lighthouse picture; once information is lost due to downsampling, it</span>
<span class="comment">% cannot be fully recovered by simply zooming in, as the missing details</span>
<span class="comment">% are not present in the original sampled data.</span>

<span class="comment">% When an image is downsampled, high-frequency details (like fine lines</span>
<span class="comment">% or textures) can be misinterpreted as lower frequencies due to the</span>
<span class="comment">% reduced sampling rate, creating the "jagged" aliasing effect.</span>

<span class="comment">% While zooming (which uses interpolation algorithms to fill in missing</span>
<span class="comment">% pixels) can make an image appear larger, it cannot generate new</span>
<span class="comment">% information that was lost during downsampling.</span>
</pre>
<img vspace="5" hspace="5" src="lab_p8_13.png" alt=""> <h2 id="16">3.2g)</h2>
<pre class="codeinput">
<span class="comment">% TASK: Compare the quality of the linear interpolation result to the</span>
<span class="comment">% zero-order hold result.</span>
<span class="comment">% Point out regions where they differ and try to justify this difference</span>
<span class="comment">% by estimating the local frequency content. In other words, look for</span>
<span class="comment">% regions of &ldquo;low-frequency&rdquo; content and &ldquo;high-frequency&rdquo; content</span>
<span class="comment">% and see how the interpolation quality is dependent on this factor.</span>

<span class="comment">% Differences between zero-order hold and linear interpolation</span>
figure(<span class="string">'Name'</span>,<span class="string">'Zero-order Hold and Linear Interpolation Difference.'</span>);
clf;
subplot(2, 1, 1); imshow(xhold);
title(<span class="string">'Zero-order Hold Image.'</span>);
subplot(2, 1, 2); imshow(xxlinear);
title(<span class="string">'Linear Interpolation Image.'</span>);

<span class="comment">% Low-frequency content refers to areas of an image with gradual changes</span>
<span class="comment">% in color or intensity, like a flat background or large smooth surfaces.</span>

<span class="comment">% High-frequency content refers to areas with sharp changes in color or</span>
<span class="comment">% intensity, like edges between objects, fine details, or textures.</span>

<span class="comment">% Compared to xhold, the linear interpolation image (xxlinear) is more</span>
<span class="comment">% closely matches the original lighthouse image. Although the</span>
<span class="comment">% reconstruction procedure can eliminate some aliasing issues from the</span>
<span class="comment">% down sampled lighthouse image, we can still distinguish the two images.</span>
<span class="comment">% This is because it is carried out linearly, for every column and row,</span>
<span class="comment">% this method performs far better. Instead of viewing the full image as a</span>
<span class="comment">% single, huge image, it breaks it up into smaller, more manageable</span>
<span class="comment">% portions. How high or low frequency of the image sampling determines the</span>
<span class="comment">% interpolation quality.</span>
<span class="comment">% It's possible to obtain something akin to the xhold image if the</span>
<span class="comment">% frequency is high in comparing to the sampling rate.</span>

<span class="comment">% Are edges low frequency or high frequency features?</span>
<span class="comment">% Answer: Edges are considered high frequency features in image processing</span>
<span class="comment">% and analysis; this is because they represent areas where the intensity</span>
<span class="comment">% changes rapidly, which corresponds to high frequencies in the frequency</span>
<span class="comment">% domain of an image.</span>
<span class="comment">% High frequency means rapid change, low frequency means smooth change.</span>
<span class="comment">% When analyzing an image using Fourier Transform, the high frequency</span>
<span class="comment">% components are typically located at the outer edges of the frequency</span>
<span class="comment">% spectrum, while low frequencies are concentrated in the center.</span>

<span class="comment">% Are the fence posts low frequency or high frequency features?</span>
<span class="comment">% Answer: fence posts would be considered high-frequency features because</span>
<span class="comment">% they represent sharp edges and rapid changes in intensity within an</span>
<span class="comment">% image, which are characteristics of high frequencies.</span>
<span class="comment">% Example: Low frequency features: Smooth, gradual changes in intensity,</span>
<span class="comment">% like a flat sky in an image.</span>
<span class="comment">% High frequency features: Sharp edges, detailed textures, or rapid changes</span>
<span class="comment">% in pixel values, like the lines of a fence post.</span>

<span class="comment">% Is the background a low frequency or high frequency feature?</span>
<span class="comment">% Answer: a background is generally considered a low-frequency feature as</span>
<span class="comment">% it typically represents large, smooth areas with gradual changes in</span>
<span class="comment">% color and intensity, unlike high-frequency features which are sharp</span>
<span class="comment">% edges and fine details like textures or lines.</span>
<span class="comment">% Low frequencies correspond to areas where the intensity changes slowly,</span>
<span class="comment">% which is characteristic of a background area.</span>
<span class="comment">%  High frequencies represent areas with rapid changes in intensity,</span>
<span class="comment">% like edges or fine details within an image.</span>
</pre>
<img vspace="5" hspace="5" src="lab_p8_14.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
% ========================================================================== 
% ECE 5530/ ECE 6530 Digital Signal Processing, ECE Dep., The University of Utah 
% Group Project
% Team: Kyle G. Gayliyev, Skylar Stockham, Eddie Franco
% ========================================================================== 
close all;
clear;

%% Sampling, Aliasing and Reconstruction : Lab P8 Exercise: 3 Lab Exercises 
%% Overvew
% The objective in this lab is to introduce digital images as a second 
% useful signal type. We will show how the A-to-D sampling and the D-to-A 
% reconstruction processes are carried out for digital images. 
% In particular, we will show a commonly used method of image zooming is 
% actually D/A reconstruction, but it gives “poor” results—a later lab will 
% revisit this issue and do a better job.

 %% 3.1 Down-Sampling 
 %% Questions. 
 % Answer the following questions for the lighthouse picture,
 % downsampled by two.
 % a) Describe how the aliasing appears visually. Compare the original to 
 % the downsampled image. Which parts of the image show the aliasing 
 % effects most dramatically?
 % b) This part is challenging: explain why the aliasing happens in the 
 % lighthouse image by using a “frequency domain” explanation. 
 % In other words, estimate the frequency of the features that are 
 % being aliased. Give this frequency as a number in cycles per pixel. 
 % (Note that the fence provides a sort of “spatial chirp” where the 
 % spatial frequency increases from left to right.) Can you relate your 
 % frequency estimate to the Sampling Theorem?
 % You might try zooming in on a very small region of both the original 
 % and downsampled images.
%% Answers. 
% First, let's downsample the lighthouse picture by two. To do so,
% we upload the "lighthouse.mat" given file. Then, we apply the following
% formula to download it and save the downloaded file into a new
% variable.

% Upload the "lighthouse.mat" given file
% lighthouse = importdata('lighthouse.mat');
load lighthouse.mat;

% Downsampling the lighthouse image by factor of 2
%Formula: wp = ww(1:p:end,1:p:end); %downsampling the "ww" by a factor of p.
downsampled_lh_2 = xx(1:2:end,1:2:end); % size : 163x213
whos;

%% 3.1a) 
% Let's draw the image so that we can see and compare the results.
% Plot the original lighthouse image 

figure('Name','Lighthouse Original Image.');
clf;
imshow(xx); title('Lighthouse Original Image.');

% Plot the downsampled lighthouse image 
figure('Name','Lighthouse Downsampled Image by Factor of 2.');
clf;
imshow(downsampled_lh_2);
title('Lighthouse Downsampled Image by Factor of 2.');

% Comparing both on the same figure
figure('Name','Comparing Lighthouse Original VS Downsampled Image by Factor of 2.');
clf;

subplot(1, 2, 1); imshow(xx); 
title('Original Image');
subplot(1, 2, 2); imshow(downsampled_lh_2); 
title('Downsampled Image by Factor of 2.');

% subplot(2,1,1);
% imshow(xx);
% subplot(2,1,2);
% imshow(downsampled_lh);

% Aliasing appears visually as jagged edges, stair-step patterns, or 
% a "pixelated" look, particularly along sharp transitions between 
% colors or high-contrast areas in the image.
% In this example, the downsampled image appears less smooth and more 
% distorted compared to the original lighthouse picture. Due to aliasing, 
% some part of the fence, and the lighthouse itself appear blurred or 
% distorted in the downsampled version. The aliasing effect is most 
% noticeable in areas with fine details, such as the roof shingles, 
% the fence, and the edges of the windows and doors.

% In summary, where high spatial frequencies are present in the downsampled 
% image, aliasing is visually represented as a distorted, jagged pattern. 
% The aliasing effect is especially apparent in regions with fine details, 
% such the fence, the windows and door margins, and the roof shingles, 
% when comparing the downsampled and original lighthouse image.

%% 3.1b) 

% Frequency Domain Analysis
reg_original = xx(100:150, 100:150); %Extract the regions of interest
reg_downsampled = downsampled_lh_2(50:75, 50:75);

% Perform 2D Fourier Transform to analyze the frequency
fft_original = fft2(reg_original); 
fft_downsampled = fft2(reg_downsampled);

% Frequency Estimation and Comparation
figure('Name','Frequency Estimation and Comparation.');
subplot(1, 2, 1); imagesc(abs(fftshift(fft_original))); 
title('Original Image Frequency');
subplot(1, 2, 2); imagesc(abs(fftshift(fft_downsampled))); 
title('Downsampled Image by Factor of 2 Frequency.');

% The lighthouse image's aliasing is caused by the downsampled image's 
% inability to completely capture the high frequency information in the 
% original image. This can be explained in the frequency domain by the 
% fact that the frequency of the aliased features is more than half of the 
% sampling rate. This is called the Nyquist rate, and it says that the 
% sampling rate must to be more than twice the maximum frequency in the 
% original image to avoid aliasing.

% The lighthouse image's peak frequency is around one cycle per pixel 
% because the spatial frequency rises from left to right (the fence 
% creates a kind of "spatial chirp"). The maximum frequency that the 
% downsampled image can record is 0.5 cycles per pixel because it only 
% has half as many pixels as the original. Aliasing would occur at 
% frequencies higher than this.

% Because the downsampled image has a lower sampling rate (fewer pixels), 
% it is unable to capture the high frequency information seen in the 
% original image, which is why aliasing occurs. The Sampling Theorem, which 
% asserts that the sample rate must be more than twice the maximum 
% frequency in the signal in order to adequately capture it, is broken 
% by this.

% The reason for the aliasing is that the high frequency information 
% in the original image is not captured by the downsampled version. 
% About 150 cycles per pixel is the highest frequency found in the original 
% image. The sample Theorem states that the sample rate must be at least 
% twice the highest frequency in the image, or 2*150 = 300 cycles per 
% pixel, in order to prevent aliasing. Aliasing comes from the downsampled 
% image's inability to capture high frequency information due to its 
% sampling rate of only 150 cycles per pixel.

%% 3.2 Reconstruction of Images

% When an image has been sampled, we can fill in the missing samples by 
% doing interpolation. For images, this would be analogous which is part 
% of the reconstruction process in a D-to-A converter. We could use a 
% “square pulse” or a “triangular pulse” or other pulse shapes for the 
% reconstruction.

% For the reconstruction experiment, we'll use the lighthouse image, 
% down-sampled by a factor of 3.

% Downsampling the lighthouse image by factor of 3
downsampled_lh_3 = xx(1:3:end,1:3:end); % size : 109x142
whos;

% Plot the downsampled lighthouse image 
figure('Name','Lighthouse Downsampled Image by Factor of 3.');
clf;
imshow(downsampled_lh_3);
title('Lighthouse Downsampled Image by Factor of 3.');
% The goal is to reconstruct an approximation to the original lighthouse 
% image, which is the size of 256x256, from the smaller down-sampled image.

%% 3.2a) 
% The simplest interpolation would be reconstruction with a square pulse 
% which produces a “zero-order hold.” Here is a method that works for 
% a one-dimensional signal (i.e., one row or one column of the image),
% assuming that we start with a row vector xr1, and the result is the
% row vector xr1hold.

xr1 = (-2).^(0:6);
L = length(xr1); % Length of the row vector xr1.
nn = ceil((0.999:1:4*L)/4); %<REPLACE_WITH_DASH_DASH Rounds up to the integer part
xr1hold = xr1(nn); % The result row vector

% TASK1: Plot the vector xr1hold to verify that it is a zero-order hold 
% version derived from xr1.

figure('Name','Zero-order Hold Version.');
clf;
subplot(2, 1, 1); stem(xr1hold); hold on; plot(xr1hold);
xlabel('Square Pulse Producing a “zero-order Hold.”')
ylabel('The Result Row Vector');
hold off;
title('Plot of The Zero-order Hold Version.');
subplot(2, 1, 2); imshow(xr1hold);
title('Image of The Zero-order Hold Version.');


% TASK2: Explain what values are contained in the indexing vector nn.
% Answer: The indexing vector nn contains the indices used for zero-order 
% hold interpolation. The values that are contained in the indexing vector 
% nn are the integer values. 

% TASK3: If xr1hold is treated as an interpolated version of xr1, then 
% what is the interpolation factor?
% Answer: The interpolation factor is determined by the length of nn 
% relative to the original row length. Interpolation_factor = length(nn)/L;
% Using this formula, 

Interpolation_factor = length(nn)/L;

fprintf('The Interpolation Factor =');
disp(Interpolation_factor);

% The Interpolation Factor =     4.



%% 3.2b) 
% Process all the rows of downsampled_lh_3 to fill in the missing points. 
% Use the zero-order hold idea from part (a) with an interpolation factor 
% of 3. Call the result xholdrows. Display xholdrows as an image, and 
% compare it to the downsampled image downsampled_lh_3; compare the size 
% of the images as well as their content.

xholdrows = zeros(size(downsampled_lh_3));
for i = 1:size(downsampled_lh_3, 1)
    xr1 = downsampled_lh_3(i, :);  % Take one row at a time
    nn = ceil((0.999/1/4 * length(xr1)) / 4);
    xholdrows(i, :) = xr1(nn);
end

% Display xholdrows as an image
figure('Name','Zero-Order Hold Interpolation for Rows.');
clf;
imshow(xholdrows);
title('Zero-Order Hold Interpolation for Rows.');

% Compare xholdrows to downsampled_lh_3 in terms of size and content.

% It saves the interpolated rows in the matrix xholdrows and uses the same 
% zero-order hold interpolation method as in part (a) for every row.


% The final xholdrows matrix is shown as a picture, representing the full 
% image with interpolated rows. This illustrates how zero-order hold 
% interpolation is used to fill in the missing spots.

size_downsampled_lh_3 = length(downsampled_lh_3);
size_xholdrows= length(xholdrows);

fprintf(' The Size of downsampled_lh_3 =');
disp(size_downsampled_lh_3);
fprintf(' The Size of xholdrows =');
disp(size_xholdrows);

% xholdrows and downsampled_lh_3 both have some amount of data.

% xholdrows and downsampled_lh_3 picture comparation:

figure('Name','xholdrows and downsampled_lh_3 Image Comparation.');
clf;
subplot(1, 2, 1); imshow(downsampled_lh_3); 
title('Downsampled Lighthouse Image By Factor of 3.');
subplot(1, 2, 2); imshow(xholdrows);  
title('xholdrows Image.');

%% 3.2c) 
% Process all the columns of xholdrows to fill in the missing points 
% in each column and and call the result xhold. 
% Compare the result (xhold) to the original image lighthouse. 

% Fill in the missing points for all columns in xholdrows using zero-order
% hold interpolation:

xhold = zeros(size(xholdrows));
for i = 1:size(xholdrows, 2)
    xr1 = xholdrows(:, i);  % Take one column at a time
    nn = ceil((0.999/1/4 * length(xr1)) / 4);
    xhold(:, i) = xr1(nn);
end

% Looping through columns,the code iterates through all the columns of the
% xholdrows matrix obtained in part (b).
% Like section (a), the zero-order hold interpolation approach is applied 
% for each column, and the interpolated columns are stored in the matrix 
% xhold. The interpolation for the full image is finished in this stage.

figure('Name','xhold VS Original Lighthouse Image Comparation.');
clf;
subplot(1, 2, 1); imshow(xx); 
title('Original Lighthouse Image.');
subplot(1, 2, 2); imshow(xhold);  
title('xhold Image.');

%% 3.2d) 
% Linear interpolation can be done in MATLAB using the interp1 function 
% (that’s “interp-one”). Its default mode is linear interpolation, which 
% is equivalent to using the ’*linear’ option, but interp1 can also do 
% other types of polynomial interpolation.

% TASK: For the example of a 1-D signal below, what is the interpolation 
% factor when converting xr1_1 to xr1linear?

n1 = 0:6;
xr1_1 = (-2).^n1;
tti = 0:0.1:6; %REPLACE_WITH_DASH_DASH locations between the n1 indices
xr1linear = interp1(n1,xr1_1,tti); %REPLACE_WITH_DASH_DASH function is INTERP-ONE

figure('Name','Signal Example For Section 3.2d.');
clf;
stem(tti,xr1linear);hold on; plot(tti,xr1linear); hold off;
title('a 1-D Signal Example For Section 3.2d.');
xlabel('Locations between the n1 indices')
ylabel('Linear Interpolation')

% Interpolation Factor Calculation

L_xr1_1 = length(xr1_1); % Length of the row vector xr1_1.
Interpolation_factor_xr1_xr1linear = length(tti)/L_xr1_1;

fprintf('The Interpolation Factor When Converting xr1_1 to xr1linear =');
disp(Interpolation_factor_xr1_xr1linear);

% Answer: The Interpolation Factor Converting xr1_1 to xr1linear = 8.7143.

%% 3.2e) 
% In the case of the lighthouse image, we need to carry out a linear 
% interpolation operation on both the rows and columns of the down-sampled 
% image downsampled_lh_3. This requires two calls to the interp1 function,
% because one call will only process all the columns of a matrix.

% Name the interpolated output image xxlinear.


% Define the interpolation factor 
interpolation_f = 3;

% Initialize a matrix for an interpolated image
xxlinear = [];

% Perform linear interpolation for each row
% Iterate through rows of the downsampled image, perform linear 
% interpolation on each row separately.
for i = 1:size(downsampled_lh_3, 1)
    row = downsampled_lh_3(i, :);
    xxlinear_row = interp1(1:length(row), row, 1:(1/interpolation_f):length(row));
    xxlinear = [xxlinear; xxlinear_row];
end

%% 3.2f) 
% Task: Compare xxlinear to the original image lighthouse. Comment on the 
% visual appearance of the “reconstructed” image versus the original; 
% point out differences and similarities. 
% Can the reconstruction (i.e., zooming) process remove the aliasing 
% effects from the down-sampled lighthouse image?

% xxlinear and original lighthouse image comparation:

figure('Name','xxlinear and Original Lighthouse Image Comparation.');
clf;
subplot(2, 1, 1); imshow(xx); 
title('Original Lighthouse Image.');
subplot(2, 1, 2); imshow(xxlinear);  
title('xxlinear (Linear Interpolation) Image.');


% Compared the “reconstructed” image versus the original, we observe that
% the “reconstructed” image is low quality. It has aliasing. It looks wider
% and bigger, there are lots of quality issues on the fence, lighthouse
% structure, house structure, and telescope. The number of items are
% similar.

%  The linear interpolation reconstruction (i.e., zooming) process didn't 
% remove the aliasing effects from the down-sampled lighthouse image.

% No, a simple reconstruction process like zooming (interpolation) cannot 
% completely remove aliasing effects from a down-sampled image like a 
% lighthouse picture; once information is lost due to downsampling, it 
% cannot be fully recovered by simply zooming in, as the missing details 
% are not present in the original sampled data.

% When an image is downsampled, high-frequency details (like fine lines 
% or textures) can be misinterpreted as lower frequencies due to the 
% reduced sampling rate, creating the "jagged" aliasing effect.

% While zooming (which uses interpolation algorithms to fill in missing 
% pixels) can make an image appear larger, it cannot generate new 
% information that was lost during downsampling.

%% 3.2g) 

% TASK: Compare the quality of the linear interpolation result to the 
% zero-order hold result. 
% Point out regions where they differ and try to justify this difference 
% by estimating the local frequency content. In other words, look for 
% regions of “low-frequency” content and “high-frequency” content 
% and see how the interpolation quality is dependent on this factor.

% Differences between zero-order hold and linear interpolation
figure('Name','Zero-order Hold and Linear Interpolation Difference.');
clf;
subplot(2, 1, 1); imshow(xhold); 
title('Zero-order Hold Image.');
subplot(2, 1, 2); imshow(xxlinear);  
title('Linear Interpolation Image.');

% Low-frequency content refers to areas of an image with gradual changes 
% in color or intensity, like a flat background or large smooth surfaces.

% High-frequency content refers to areas with sharp changes in color or 
% intensity, like edges between objects, fine details, or textures.

% Compared to xhold, the linear interpolation image (xxlinear) is more 
% closely matches the original lighthouse image. Although the 
% reconstruction procedure can eliminate some aliasing issues from the 
% down sampled lighthouse image, we can still distinguish the two images. 
% This is because it is carried out linearly, for every column and row, 
% this method performs far better. Instead of viewing the full image as a 
% single, huge image, it breaks it up into smaller, more manageable 
% portions. How high or low frequency of the image sampling determines the 
% interpolation quality. 
% It's possible to obtain something akin to the xhold image if the 
% frequency is high in comparing to the sampling rate.

% Are edges low frequency or high frequency features?
% Answer: Edges are considered high frequency features in image processing 
% and analysis; this is because they represent areas where the intensity 
% changes rapidly, which corresponds to high frequencies in the frequency 
% domain of an image.
% High frequency means rapid change, low frequency means smooth change.
% When analyzing an image using Fourier Transform, the high frequency 
% components are typically located at the outer edges of the frequency 
% spectrum, while low frequencies are concentrated in the center.

% Are the fence posts low frequency or high frequency features? 
% Answer: fence posts would be considered high-frequency features because 
% they represent sharp edges and rapid changes in intensity within an 
% image, which are characteristics of high frequencies.
% Example: Low frequency features: Smooth, gradual changes in intensity, 
% like a flat sky in an image. 
% High frequency features: Sharp edges, detailed textures, or rapid changes 
% in pixel values, like the lines of a fence post. 

% Is the background a low frequency or high frequency feature?
% Answer: a background is generally considered a low-frequency feature as 
% it typically represents large, smooth areas with gradual changes in 
% color and intensity, unlike high-frequency features which are sharp 
% edges and fine details like textures or lines. 
% Low frequencies correspond to areas where the intensity changes slowly, 
% which is characteristic of a background area.
%  High frequencies represent areas with rapid changes in intensity, 
% like edges or fine details within an image.

##### SOURCE END #####
-->
</body>
</html>
